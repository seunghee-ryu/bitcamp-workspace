#include <stdio.h>
#include <stdlib.h>

int main() {
  
  int i[3];
  i[0] = 100;
  i[1] = 200;
  i[2] = 300;
  
  printf("%d, %d, %d\n", i[0], i[1], i[2]);
  
  int* p;
  
  //p = &i[0];
  p = i;
  printf("%d\n", *(p+2));
  
  //byte =(byte*)malloc(12);
  // 준비된 12바이트의 메모리를 1바이트 단위로 잘라서 사용하고 싶을 때
  //앞에 적어준다
  //4바이트로 나눠서 사용하고 싶으면 int
  
  int* p2 = (int*)mallo(sizeof(int * 3));
  *p2 = 110;
  *(p2 + 1) = 220;
  *(p2 + 2) = 330;
  
  printf("%d, %d, %d\n", *p2, *(p2 + 1), *(p2 + 2));
  printf("%d, %d, %d\n", p2[0], p2[1], p[2]);
  
  printf("%d\n", *(p2+3));
  printf("%d\n", p[3]);
  
  free(p2);
  
  //해제된 메모리 포인트에 접근해도 오류가 뜨지 않는다.
  //이것을 막기 위해 만들어진 언어가 러스트이다.
  //러스트로 만들어진 것은 파이어폭스가 대표적이다.
  printf("%d, %d, %d\n", *p2, *(p2 + 1), *(p2 + 2));
  
  
  
  int* x1;
  
  x1 = (int*) malloc(12); // 예) 100번지
  x1 = (int*) malloc(120); // 예) 200번지,
  
  // 100 번지는 주소를 잃어버려서 사용할 수 없다.
  // dangling object = garbage
  
  free(x1); // 메모리 해제. 200번지 주소는 무효하다.
  x1[0] = 34; //x1은 무효한 주소를 갖고 있다.
  //무효한 주소를 dangling ponter라고 부른다.
  
  
  
  
  
  
  
  
  
  
  
  
  
  return 0;

}

// malloc(4) 4바이트의 메모리를 준비하고 그 주소값을 변수에 넣어라
// *p;, * p; 는 포인터 변수. 주소를 저장하는 변수.
// 주소도 숫자 = 정수 변수 
// C 언어는 64비트 운영체제면 int는 64비트, 32비트 운영체제면 int는 32비트
// 메모리 주소는 배정받은 메모리의 첫번째 바이트의 주소
// &i1; 는 i1의 주소를 p에 넣어라
// 명령창에서 폴더로 가서 gcc를 사용
// p = i; 배열 이름 자체가 그 배열의 시작주소를 말한다.
// i는 수가 바뀌지 않는다
// malloc을 쓰면 24시간 계속 꺼지지 않는 프로그램일 경우
// 마지막에 메모리를 반납해줘야 한다